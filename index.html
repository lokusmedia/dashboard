function parseDateFlexible(s){
  if (s == null || s === "") return null;

  // numbers (excel serial or unix ms)
  if (typeof s === 'number' && isFinite(s)){
    if (s > 1e12){                    // looks like epoch ms
      const d = new Date(s);
      return new Date(d.getFullYear(), d.getMonth(), d.getDate());
    }
    const ms = (s - 25569) * 86400 * 1000; // Excel serial
    const d  = new Date(ms);
    return new Date(d.getFullYear(), d.getMonth(), d.getDate());
  }

  let t = String(s).trim();

  // ISO full (YYYY-MM-DDTHH:mm:ss[.sss]Z or with offset)
  if (/^\d{4}-\d{2}-\d{2}T/.test(t)){
    const d = new Date(t);
    if (!isNaN(d)) return new Date(d.getFullYear(), d.getMonth(), d.getDate());
  }

  // ISO date-only (YYYY-MM-DD) â€” avoid UTC parsing quirks
  if (/^\d{4}-\d{2}-\d{2}$/.test(t)){
    const [y,m,d] = t.split('-').map(n=>parseInt(n,10));
    return new Date(y, m-1, d);
  }

  // dd/mm/yyyy or mm/dd/yyyy (heuristic)
  if (t.includes('/')){
    const [a,b,c] = t.split('/').map(x=>x.trim());
    if (a && b && c){
      if (+a > 12) return new Date(+c, +b-1, +a); // dd/mm/yyyy
      if (+b > 12) return new Date(+c, +a-1, +b); // mm/dd/yyyy
      return new Date(+c, +b-1, +a);              // default to dd/mm
    }
  }

  // dd.mm.yyyy
  if (t.includes('.')){
    const [d,m,y] = t.split('.').map(x=>x.trim());
    return new Date(+y, +m-1, +d);
  }

  // last resort
  const d = new Date(t);
  if (!isNaN(d)) return new Date(d.getFullYear(), d.getMonth(), d.getDate());
  return null;
}
